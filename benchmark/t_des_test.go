package main

import (
	"crypto/des"
	"encoding/base64"
	"fmt"
	"io"
	"os"
	"testing"
)


func TestDecrypt(t *testing.T) {
	var data = "K2EzbENpZE5mc2lLdDRkb2N6WnorWHNjSTBzMzZ1N3R4RU1aZGZRemdERkt3WjRJMW9lOXlyaFg4aERud1FNejVtc0VjYjFUVWNlN3owVzJ3azRxalRiVnZUTThrdTFZcWxIeGJGSFJ0SXQ4eE9Hei9vRXJNYVhQd2RUVW1vYVNnMWtKZjhkS2lseEd5bFJWVENtdjhBaDhFbnlUMHJzTE50VzlNenlTN1ZqaVNCcllVM1o1YUF5SUE4VGdhcEhxdkQzdFFFbGc3U3ZvRWR3SzNxUzlRNzJtaWVoalptem9HMGIvZUViMEFQbVpQY3EyK2NkYXMxN1hQTE9kWTFjMTlnL2tsbnNlWjZWRU9ZZWgvMDBWaEJXOEtJaG05RGgwbkt3NUZDNFlNdGRkRmY3VUtvNm1qcnViYXZka3RSYmo0L2NoRGs2TzFWU3RDcGkzN0lZWUhLbDRQbkFFT3FGSVROc3BodUxXZlZNMFF5c2ZKaVVJUEJBR0FHU2Y5d3h2Q1Nqazl3cWhTMGhrbW5HQjNoajBqa1dETng3U2dmY1hXaGJQMXg2RFBxaXRGWWtmQU1aYWF6TGhpZ3V5T2Nqa0NLY0VIM0JpcWRWem1Ec05MajZsd1pyZ3EycklxMS9BZURLMkkyS0hHd0JsaWJzZWsxK1JBT2NHT0s2TUlsY0FrUVQrU2llb3EzUXNKVFYvcndyZG1OWTJ5eW80QlBsTXU4OUZ0c0pPS28wMjFiMHpQSkx0V0dtTlhSbUFWUWJXRzdEb0RmdGxUWkFKRGt4Ly9xWWdPMmZhQXd2ZVpuc0I0ZlZiVmVKcXFPS1VSY0VqanpOWmV0RFkyMFhtWldRV2FOV3h6dXhNNUg0eEtROFZ4cWFOWTZBYmErRnhIOUZVTG5May9oWnZ4bDdNZjIwZ3gyUUZCUWdlNE9CSkNYV0ZaTmF5WnppbnVUU0FhMWtLTTFQdkFIUldEMDNLWU4xY2pQSkRzbWsvaHhwZnBxREF2TjZVYWxVREtuWWhkNmVSbjBjS0lOeldlcU1nUGI3OTIyZnVPR01vRGxkQi9qRlZTNHI0SEJwV1hPL3IvWGJxcFN0TTg1Mk96VGtYKzdKd2ltQUFZUzYwQ3lqMzhwem1LVE80Zlk4UjQ2cXVWTzZJZ24zNGpGUHZLN1drWDRVYjd4a0h5WTd0OXZEYTdvcXhUWDZCZnRESHBDeU9PVS9GOUFweFVIaGlrcjI2bWUwNEw3UDlJQkhlQTBaNzdHMWpLMWJtUFEwMElZS0RBQm9uMmpDV3VVVnIvTU9ORUxMSXRFekJVQnd1TXZpd2JUU0Evd1gvTFVoQ0dSUWNLUVZzeVpUb3V1WWl2VnErc1B4YWUrY016WHk0REJHcVExUHF2cU13Q2V3NDFvdENLQU1MZTBHYS9NWHlqNFNLNkZFQUQrWmx0RUozRVhkYytuVGdrZGlvVmhyQ2JXRFBIaG01QXNZVURUNU05eVlZWUF5bWhBM2NlYjhGRkhMeUFuejB1OUhsWUFFTitJYVdoVisvbGQweTBLeFlKNkU2VWtZR2w0U3ZQWVR5VTRjaHF6OUs0U1ljT3pUQjRYSXFUVUNFaVlweW9ZbEpCbENzZExaTkZKMWFEcVRnOHZzSUFqVUNHZXMyUi9mWlpsTHN1V1RlRFExSm9LK04vZndiY1B6K20relBlVDdHRUg0YkdFOVY2RloxZ0p2YnhXUDk1RUxEbjZpT2hUeWtSVHo1Yk9zbkhoMVhSWHFpSjFvenRtTG52Wk40WkdxS1hjYWV3amNkekZZdVJMRWVndTNLMFl2Zm15UVJmTFpwdDlab0hwa3hJY1lISmR1OTJWNW1ibWNPdytsWTlBRUZoWjdlc1NmcTE3dXdHbjkyUkdWSmVZM3NaRy9GMVIzbDBXZTg1YTY4R0N4TzRkcWg0ZW9ORFVtZ3I0MzkvSnNkai9ScGlYVHBuZUpWZys2MnFFbnppRnVIcU0xU0FndG8rZktVTE1VS1ZUclRqUGJZVDRxd0lMZmZmZFJLTXR3c2FBbVhuY1IyQ3ZoNktrZ2J4R0xJT293V0RmS1RQQWxBc0h0Y0NXR0dlK3h0WXl0VzVqME5OQ0dDZ3dBYUo5b3dscmxGYS96RGpSQ3l5TFJNd1ZBY0xqTDRzRzAwZ0FaNmt3dHlhTUNvWnBRQTJJb3prZTdlQWhEL0E5RmNMRk9HNkxjWnIzMS9tTmQxN29yeHpXOUhobzBNOGlpMTlzRzBqUUYzNUEvalYvR3ZFYWJuRXRLWTlpMWpjWFljN3VRSnIwVTFiNk82cXBHYnR3U1l0SitobmlIT0ZsSmJnaEZndkRsaE92ZVUyVEQ5OTh6VWZNdG1nUlhkRWI1WExkajVWRk9BeXBLTkFEL282YnRJOXpBU1RtNldjQWhJczkvTWpqei9QQ3dUK1BlckJEcU5JOGd4VXlZekVLZ3hpdzRwd2srRTA5UGxnNHNVNWYxN2NTNGp1TUJjYkxHclhaOGlweEdpOVhvclRDSloxQTFReFVKb3JSRjVRVWpOYzlTekdLNXNGeHN2bnJ1ODVtNlUvQnpKdGNaL1dSaVhDem1XbTFiZ21XNGYrOXNXZzArS1JPbldRMjR5TFhoMW04UFZNU0dzTGgxQWQ2RWpjMXFSdndyNzJ4YURUNHBFNmRaRGJqSXRlSFdibENpT0RvWUd1UG1CMFV2ZUs2U05Rc1M3ZFFEa2ZpZU1uTVBBeDhwNFNOUCtrRFI5RW1uSXJJcDdJaTV4R2pwYk8vR2FBVnFTWUJwMnNqMnpNZmxNZ2JMdGhONHNUS2hiVVI3RWhVdFgxbnluOTlZWW0wb3NDVHZ4bWdGYWttQWErbzZtaDhmM2txS01DWXZzZURHUmlGRWV4SVZMVjlaOHdJMEgrODNkZmIxc0liZkhCSzRYaTRmck1LVnN5VWMvVmJ0eHpNVTBNcVlnQlo1Q2NQZU5CZXZwU2xqUXFBZy9Va3YrLzFzRktXd0owR0dmWHpOWTg2aUVmMzYyUHM4QmZyZWg3dnkreG1ESHRVdUlyeGpwbkxMWjBhUWNhcUFKRU45YWV4ZHlFUTltaUVERDBWaVRRbVc4bkxUa3I1dnF3clRwQ3hydFYvQlVMc3RFbFNHOXFmTWhjKy90YlhhZDNMWmpTV2M2VEtFNytWaSt5ZVVHcTZwRGxxNmFEank5WHJKQkZ6L3V5OUUwL1VEMXRTbmhFcUFPN0FHQUhZYWpSbHl2TDlKWHpKelErTnpVZkVpTGh5eURZeEdkZExUOHF0VWlFQk1PUkNyamg0MVdlaEl2OTYzbzNmYVQ3cmFNbm5xTFE4SG5pbEMvNG5tSHN1QlQxZXJ0c1BkMWRGaElEVUJjZnFyQytQUGs4Mi81dzhHSkc0SXYxRDRSMnJxdDVUOWlCeWxBVWRyRTRFMVMrS0FjdUFOVXNqdmQ1cWVWNVBOditjUEJpUnVlZW90RHdlZUtVTGxxT2xkTmx6R3NaODZ3UWVSWnpUbTg2V0NtZ1ZYY2tSbDQxOWlwVmQweG82NnRvZ3c4VXlMaHRDYm5jTmtlbmFXNHBSdVB2T2hrbzY2dG9ndzhVeUpwb0wxYldaSmQyMjMvb3hJQjc4dkc2SFliSFV6T1BCVlgyZFlRV1BmaDBEdzhxYXlwdjE0Vlh5elllQjNjaTB2aEkwaFd6MzhPMnV6TE5vSXZzYXBoVHU3NFVOMjBnWmZtdjhISHBHR2FyeWVWZmRGN1dqTW11NGNudmh4c1p2Y1NBbmNwVjY1U0NMNVVySHIvVG5VRmt5UWZtRXBpRUtQMXFPcGxZQ25VZVk1Uk0xdXdvcjQvSzJMNWlTaHEzck9JMkI3UGZqRDhBZG9oc1piY2syL3RwSjh6R05QRyt0T1VPdkhaUXRXSXRpNlQ1ZFRCZXNhbDEzNEFnc005OWRLeW45eGNJY1lodzRJaWFKV2xrVXp5WHVyNnA4SFd5ZDRRZXJ2cWx4dDlOYkZ6TFJPQlVrK1Y4a0poRGxmZFZ2WEQxODlhYmJDNWVrVHRmemxpdGxheGVVd1UzekloSGoyc3U2SkxsWVNSV0NtdjhDZzRtRTV3SmlCWXpaSjFDYnRDaFBaMDk4dGhzNlNMNlVaZWtmd1RMM3ltbU9NWHBYSEkwOFRoTDl6WHJQbGoyMEwvU2JYMnYveW0wS2NyN1RsUHZTMk9BMUJSUTM1b2xYS3gwKytJcGxXaVpkSTQwVUJKUTZ6Z3A4WjVXL2hPa0w3cm1pYStmajN1Rzh4RjJvWjBJWmlqZk1GVnRGNEd3TTJrQnJpRko1VjkwWHRhTXliZCtoNTRHUElJZ2prSEllVkV6TEF6ekpha2VheDVtVlZ6ZzJ0M0pIcnZUaUlXQWZYcjUyS1VFVXpVU0htUk1iS2d2aS9HaGZvUUlnM1dxb2NKcERnWGI3UWtDRTdKc0hjMzVmUWtOS3cxMFFuNnFoN0szellLZFc1OVRkcFUzd09hc3JHRDQzMTA4dzZXQ0RrYlc0OUhIWXRwdGx4NUdvdG9hMXAzd2NIalRnTmdvSXdhOFd6MHhzcmxLam1jZGRQSmtyeU1kb2gwcnJMaVlDMUhLZlZqT0FyQmVVMDVsczB1enhkUVYzRktEZFVGQXB4NVBiMVp4NjF0VmptQmtrNXZiNGk1bmpFOGpSdFBuUDdJS1lTb3FOZC9yOHo0N3QvaXQ1SDlaTVNQNy85dGlub0JYaVZhSTNUajBjaFZGVzV5QVBDSDB3SzVJWDQySjdaemtCNndvNjZ0b2d3OFV5S1Rua0xNN3ptZkZJTlpDWC9IU29wY1J5SWhqeE15eDlQWDJLSW1peElyYm1mNGVEWnEvOVQxaHk4dzBzYlo2VC8yMHlXV0NuOE9hWmxMM3FBcW1hakRyckkwL0g0bllRcG9WQlc2OU42TDROb2lDazBtM0FrQVNOWDAzSldPcENqNVk5dEMvMG0xOXBDUkVpMVczL0pBRzhUZWVvNGd6bXh6ZHEzbjlhNU1mQUE3Tk1pWkd5c2FxSERzUWlTQWttYjhDQ3hVNVJidVY4MGZJd0M0N1JuaTcyMzZodkdKWmFJbmxYM1JlMW96SnJxcUpaQmRjZ3FFbGl0czBVTnNJaW1rcytmczV3WlJ6QVZqbGJDTnQ3dUt6UVkyVkRadThUOTR4RUJXYWw5cnpmb3JhWG5KM2tNOHhxOWs2cE9XQnZDYzZBQ1J5c3dYV1JLRFBLWGN4bHZPZmVlSjlJUW9mMURlM2VMc2wyYnUzZ01pdWF0WXFEVEFjZHYzdUFXNmovWUswcDM5SWpteGFwSXA1emkzampuOUxBS240Qjc4cCtBSTlVci84VlZaUlY5eTVld3FFMnJOeVE2RXVDTmNDS1JoZEwrd1FTVGZVTXkzWGNpTGp6LzVKTUZMMVM5RVU5VTBKUEdlT2d1ZHpXbG8xV1pDMHNybXd1UHlRSlE0Qk1WWURDWUpiOFBVT2VLL1RtalNLeXRZL0dwTTR0ckxsOWdPV2l4enpmTnRIZ1RBNE5CK3A3YzFOcnllbjZqemlHbGVHZnp3MkJwamhQWXJSWW1oazdudE9aVmM1cFh3U2tvUFBvb1JkVEFQVDYwcldudVJKRzQ0ajRQYnN4cUp0cGJUOTRRWFVjMGtMaGhUcW9mbTF2RXpuc044WnZkSWwzTkEwNzk1S3BjOXZ0UFFzc0xNeVdSazE4L2N1eVVzUDB1MzljalJwYXpUVDYzUzFqa1FkL3NJMXg4SHBRcVE1dGFGMXlNU2FQcVFNZFM5OWRhcUxERUlOREQrRE9TcHd4UWpTM1NKdEh5aEFoMDRSRHBQbUlTUDhlVnMwKzArS2VTeUxXY0lLT1RQZ0Z2WDAxS3RieHFYWXpUTE4zV0dwZFFxMm1jZWdmMnp5bDFDOGZidDgxamhTSGI1V3Jac25NbUlHaGphSUM1akRhdjlDdWgyVDE1M24vZ0dOVXhVODlTOGFETUgvaC9jcHgxOEVtYzVsUnNORTZsRnd3R1JIRDZtcEZSa3hTdlN6TGNhMFhzOG1WdEJhZ2lZcnVzNzk0aGpmbnlidlIvMjZGZGhFK25SMGdBTGorK0xoSUkwdlpleUswb29kS0Z5RndHcHowdEVTVG9sR3V3U21jUU1zZDU3ejRiRFZPUUIvVTBRUW0walpHdVM5bHBycmdGeWhlRTc4Wm9CV3BKZ0duYXlQYk14K1V5QnN1MkUzaXhNcUZ0UkhzU0ZTMWZXZktmMzFoaWJTaXdKTy9HYUFWcVNZQnI2anFhSHgvZVNvb3dKaSt4NE1aR0lVUjdFaFV0WDFuejhCRWJJRElHUUlTS0tGYkMwNDhtYVc0K01UTy9JeXpscDRtYzRDMEsyakJ1NzVJcS95STFYRU96MWdmUDQyLzVzSWJmSEJLNFhpNHVMWUg3eUc1cU1reVFmbUVwaUVLUDFxT3BsWUNuVWVZNVJNMXV3b3I0L0syTDVpU2hxM3JPSTJCN1BmakQ4QWRvaHNaYmNrMi90cEo4ekdOUEcrdE9VT3ZIWlF0V0l0aTZUNWRUQmVzYWwxMzRBZ3NNOTlkS3luOXhjSWNZaHc0SWlhSldsa1V6eVh1cjZwOEhXeWQ0UWVydnFseHQ5TmJGekxST0JVaytWOGtKaERsZmRWdlhEMTg5YWJiQzVla1R0ZnpsaXRsYXhlVXdVM3pJaEhqMnN1NkpMbFlTUldDbXY4Q2c0bUU1d0ppQll6WkoxQ2J0Q2hQWjA5OHRoczZTTDZVWmVrZndUTDN5bW1PTVhwWEhJMDhUaEw5elhyUGxqMjBML1NiWDJ2L3ltMEtjcjdUbFB2UzJPQTFCUlEzNW9sWEt4MCsrSXBsV2laZEk0MFVCSlE2emdwOFo1Vy9oT2tMN3JtaWErZmozdUc4eEYyb1owSVppamZNRlZ0RjRHd00ya0JyaUZKNVY5MFh0YU15YmQraDU0R1BJSWdqa0hJZVZFekxBenpKYWtlYXg1bVZWemcydDNKSHJ2VGlJV0FmWHI1MktVRVV6VVNIbVJNYktndmkvR2hmb1FJZzNXcW9jSnBEZ1hiN1FrQ0U3SnNIYzM1ZlFrTkt3MTBRbjZxaDdLM3pZS2RXNTlUZHBVM3dPYXNyR0Q0MzEwOHc2V0NEa2JXNDlISFl0cHRseDVHb3RvYTFwM3djSGpUZ05nb0l3YThXejB4c3JsS2ptY2RkUEprcnlNZG9oMHJyTGlZQzFIS2ZWak9BckJlVTA1bHMwdXp4ZFFWM0ZLRGRVRkFweDVQYjFaeDYxdFZqbUJrazV2YjRpNW5qRThqUnRQblA3SUtZU29xTmQvcjh6NDd0L2l0NUg5Wk1TUDcvOXRpbm9CWGlWYUkzVGowY2hWRlc1eUFQQ0gwd0s1SVg0Mko3WnprQjZ3bzY2dG9ndzhVeUtUbmtMTTd6bWZGSU5aQ1gvSFNvcGNSeUloanhNeXg5UFgyS0ltaXhJcmJtZjRlRFpxLzlUMWh5OHcwc2JaNlQvMjB5V1dDbjhPYVpsTDNxQXFtYWpEcnJJMC9ING5ZUXBvVkJXNjlONkw0Tm9pQ2swbTNBa0FTTlgwM0pXT3BDajVZOXRDLzBtMTlwQ1JFaTFXMy9KQUc4VGVlbzRnem14emRxM245YTVNZkFBN05NaVpHeXNhcUhEc1FpU0FrbWI4Q0N4VTVSYnVWODBmSXdDNDdSbmk3MjM2aHZHSlphSW5sWDNSZTFvekpycXFKWkJkY2dxRWxpdHMwVU5zSWlta3MrZnM1d1pSektZTjdFcitIM0pKeEdQRWh6cnJ6U0tDZHc4VmEvLzNRQlVtcjRKWllJaFYyNTRRUjF0VWtiYlN1MzhMdlp1M1QxQVZiY2FTVit3V3RaYXovdkszbUpuNmJ6OWFDc3hPRHBNN1Z1c2E2R0FoZXRkTmJZQ1hvcHdIeGRuT1VBaXNlTndlK1ErUnYvL2F2S2VqcjN3U3YwN1hMUE1lMnRIek5LRXM3OW5ZcTdiSjRzam14VUdMRXdBaVFBZ05HSUh2dlhUWlRPK0hEbWNoWXpsUEJCUWdNRjB0WVFYeFpjeXpvZW5VdmpBcFlkeVNCeklpT2tlMkhKZWdRRks5aGNnTlppajV1MjhvdmczUjF2SmZNNis0ejB5QWZKU1FCZDhwallIQmNuV2JITVdwYjRDZG94K3drL0s5em5wZmZkWnpQeC9QM1NCVEJoUko2YWFOTHVSRTVkanpMQkVmbFNPSlpHeC9QNGVqb3ZwcnFCUnptOEllQVdVNUNrRjRwL3Z1M1U0REZYY3ROcUphdHVVWWVaMTRWNU1BUWFOWk1TcjdpbWVocUtBMFZQZEowQ2dpcE4wY3NIYz0="
	data1, _ := base64.StdEncoding.DecodeString(data)
	origin := Decrypt(data1, []byte(desKey[:des.BlockSize]))
	originStr := string(origin)
	fmt.Println("originstr:", originStr)
	Write(&originStr)
	//加密
	secret := Encrypt([]byte(origin), []byte(desKey[:des.BlockSize]))
	Write(secret)

}
func TestEncrypt(t *testing.T) {
	//解密 secret->decode->decode->des.decrypt->origin
	//加密 origin->des.encrypt->encode->encode->secret
	origin := `{"head":{"firm_code":"","sub_signature_no":"AQY20220719163013499i68X","app_type":"APP_TYPE:H5","emp_num":"","biz_code":"payNotice","subjectStyle":"","main_part_code":"B202103190022","application_id":"YY20220719163549998OBoR","userCode":"HZZ1658213564629","partner_id":"HZZ1658213564629","amountStyle":"","remark9":"","front_env":"","remark8":"","remark5":"","remark10":"","remark4":"","remark7":"","remark6":"","remark1":"4","main_signature_no":"MQY20220719162852682jVG5","remark3":"","remark2":""},"body":{"msg":"TRADE_SUCCESS","code":"0000","data":{"pay_status":"ODR_PAY_STATUS:2","pay_chanel":"alipay","pay_serial_number":"2022080322001400171418376855","order_group_id":"a9dccf96719844ba9aac73bd230","pay_amount":"0.01","pay_card_no":"2088612964400174","order_id":"a9dccf96719844ba9aac73bd230","pay_time":"20220803114836"}}}`
	secret := Encrypt([]byte(origin), []byte(desKey[:des.BlockSize]))	
	Write(secret)
}
func Encrypt(data, key []byte) *string{
	block, err := des.NewCipher(key)
	if err != nil {
		fmt.Printf("err:%+v\n", err)
	}
	bs := block.BlockSize()
	length := len(data)
	out := make([]byte, length)
	fmt.Println("len+:", length + (8 - length % 8 ))
	if length % 8 > 0 {

		out = make([]byte, length + (8 - length % 8 ))	
		add := 8 - length % 8 
		for add > 0 {
			data = append(data, 0)
			add--
		}
	}
    dst := out
	// mark := false
    for len(data) > 0 {

		block.Encrypt(dst, data[:bs])
        data = data[bs:]
        dst = dst[bs:]

    }
	
	baseOne := base64.StdEncoding.EncodeToString(out)
	baseTwo := base64.StdEncoding.EncodeToString([]byte(baseOne))

	return &baseTwo
}

func Decrypt(str, key []byte) []byte{
	src, err := base64.StdEncoding.DecodeString(string(str))
	if err != nil {
		fmt.Printf("err:%+v\n", err)
	}
	fmt.Println("src:", src)
	block, err := des.NewCipher(key)
	if err != nil {
		fmt.Printf("err:%+v\n", err)
	}
	bs := block.BlockSize()

	out := make([]byte, len(src))
    dst := out
    if len(src) % bs != 0 {
        fmt.Println("err------->")
    }
    for len(src) > 0 {
        block.Decrypt(dst, src[:bs])
        src = src[bs:]
        dst = dst[bs:]
    }
	return out
}

func Write(text *string){


		var filename = "./log.txt"
		var f *os.File

		f, _ = os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, os.ModePerm) //打开文件
		fmt.Println("文件存在")

		defer f.Close()
		n, err1 := io.WriteString(f, *text) 
		if err1 != nil {
		   panic(err1)
		}
		fmt.Printf("写入 %d 个字节n", n)
}